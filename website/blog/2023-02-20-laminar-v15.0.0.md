---
title: Laminar v15.0.0
author: Nikita
authorURL: http://twitter.com/raquo
---

TODO TODO TODO Summary 

<!--truncate-->



## News

TODO – Update the docs before final release

TODO – Update live examples, add stuff to website home page, etc.

TODO – Add actual news, sponsors, etc.

TODO - Major Version bump

TODO – SDT generator – remove SDT dependency if you have it.

TODO – changes in target typing, and mapToTargetAs.

TODO – setValue, setChecked

TODO – Waypoint version

TODO – Is it a good idea to automatically de-duplicate data sent to Laminar DOM?? How do we force DOM update? Maybe we should disable this for now?

TODO – I think we need to disable auto-distinction, at least in props?

TODO – remove composeDistinct from splitOne – use identity for no distinction?

TODO – AjaxStream / FetchStream need an emitOnce option that defaults to false? Actually I was thinking

TODO – Add to docs – how to render svg from url (img(src="..."))


## New Laminar Features



### Improved Performance

I started using my new library **[ew](https://github.com/raquo/ew)** to get consistently fast implementations of methods like `indexOf` and `forEach` on JS types. This brings _significant_ performance improvements when rendering very large lists of children (thousands or tens of thousands of items). There were other internal changes too, but this takes the cake in terms of impact. Most of this was actually done in 0.14.2, but I didn't have time to write a blog post just for that.

If you're interested in this problem as a Scala.js library author, check out **ew**'s README and see [this bug](https://github.com/raquo/Laminar/issues/108) as a practical example.



### `flatMap` and `compose` for DOM events 

Typically, you subscribe to DOM events without explicitly creating any streams. This is simple and convenient, but it lacks the full palette of observables operators. We already had two ways to access those fancy operators in Laminar:

```scala
div(
  onClick.delay(1) --> observer, // does not compile
  inContext(_.events(onClick).delay(1) --> observer),
  composeEvents(onClick)(_.delay(1)) --> observer
)
```

This `composeEvents` method always rubbed me the wrong way because it's not discoverable – you can't find it via autocomplete after typing `onClick.`. Something prevented me from doing this earlier, but now I've realized that I can offer equivalent functionality as an `onClick.compose` method which works just like the observables' native `compose` method:

```scala
div(
  onClick.compose(_.delay(1)) --> observer,
  onClick
    .preventDefault
    .map(getFoo)
    .compose(_.filter(isGoodFoo).startWith(initialFoo)) --> observer,
)
```

I've also added a new `flatMap` method which is useful when you want to create a new observable on every DOM event. For example:

```scala
def makeAjaxRequest(): EventStream[Response] = ???

input(
  onInput
    .mapToValue
    .flatMap(txt => sendAjaxRequest(txt)) --> observer
)
```

If you use this new `flatMap` method in IntelliJ IDEA, you'll be annoyed to find that it causes the IDE to incorrectly report a false type error, at least with Scala 2. Not going to hold my breath for the fix, so I added more specialized `flatMapStream` and `flatMapSignal` methods which use simpler types, and don't trigger the false error in the IDE.

Between `flatMap` and `compose`, obtaining observables' functionality from DOM events is much more natural now, so `composeEvents` is now deprecated. **Migration** is trivial: rewrite `composeEvents(a)(b)` to `a.compose(b)`.



### Easier Integration With Third Party DOM Elements

Previously you could only use low level methods to inject foreign elements into the Laminar element tree. Now if some JS library gives you a DOM element, you can wrap it in Laminar goodness and use it like any other Laminar element, including adding event listeners and dynamically updating its properties:

```scala
def getThirdPartyMapWidget(): dom.html.Element = ???

div(
  foreignHtmlElement(getThirdPartyMapWidget()),
  // And this is how you add modifiers in the same breath:
  foreignHtmlElement(getThirdPartyMapWidget()).amend(
    onMountCallback {
      thirdPartyLibraryInitMap()
    },
    onClick --> someObserver,
    onResize --> someOtherObserver
  ),
)
```

A similar `foreignSvgElement` helper is available for SVGs.

I've also added `unsafeParseSvgString(dangerousSvgString: String): dom.svg.Element` to help render SVG strings. It requires two steps, but that inconvenience is by design, appropriate for such an unsafe API:

```scala
div(
  foreignSvgElement(DomApi.unsafeParseSvgString("<svg>....</svg>")),
  // And similarly for HTML elements:
  foreignHtmlElement(DomApi.unsafeParseHtmlString("<div onclick="alert('pwned')"></div>"))
)
```

These `unsafeParse*` methods expose you to [XSS attacks](https://owasp.org/www-community/attacks/xss/), so you absolutely must not run them on untrusted strings. Use them for including static SVG icons etc. 

All these new methods have a few variations for different use cases, you'll find them when needed.



### CSS API Improvements


#### Unit and function helpers

Previously if you wanted to set a pixel value to a CSS style prop, you would need to append "px" or some other unit to your desired number. That's annoying, and with observables it might require the overhead of creating another observable with `.map(s"${_}px")`.

You can still do it the old way, but the new API offers several ways to set style values in units like `px`, `vh`, `percent`, `ms`, etc.:

```scala
div(
  margin.px := 12,
  marginTop.px := 12,
  marginTop.px(12), // remember that all `:=` methods in Laminar are aliased to `apply` for convenience!
  marginTop.calc("12px + 50%"),
  marginTop.px <-- streamOfInts,
  marginTop.px <-- streamOfDoubles
)
```

The new API is type-safe, so for example `backgroundImage.px` does not exist, but `.url` does:

```scala
div
  // Equivalent to CSS:  background-image: url("https://example.com/image.png")
  backgroundImage.url := "https://example.com/image.png"),
  backgroundImage.url("https://example.com/image.png"), // same
  backgroundImage.url <-- streamOfUrls
)
```

I haven't decided how to treat some of the more complex composite CSS properties yet, so some of them still only accept strings, which means that you can do `borderWidth.px := 12` but can't do `border.px := 12` yet. But you can use the new `style` string helpers: `style.px(12)` returns a plain "12px" string which you can use like `border := style.px(12)`.


#### Get string values from style keyword setters

You could already use keyword shorthands like `display.none` – that modifier is equivalent to `display := "none"` – and now you can also get string constants from these shorthands with their newly exposed `value` property:

```scala
div(
  // Before
  textAlign <-- streamOfBooleans.map(
    if (_) "left" else "right"
  ),
  // After – same, but you get to marvel at your IDE knowing these symbols
  textAlign <-- streamOfBooleans.map(
    if (_) textAlign.left.value else textAlign.right.value
  )
)
```

Want a bit less boilerplate? Define a trivial implicit conversion from `StyleSetter[String]` to `String`, and you won't need to call `.value` manually. This is a bit too magicky to be included in Laminar core though.


#### Vendor prefixes

Not a super relevant feature these days, but you can now do this to set a style property along with several prefixes:

```scala
div(
  transition.withPrefixes(_.moz, _.ms, _.webkit) := "all 4s ease"
  // and similarly for <--
)
```



### More Options For Window and Document Events

Previously you could access `windowEvents` and `documentEvents` like this:

```scala
windowEvents.onPopState // EventStream[dom.PopStateEvent]
documentEvents.onClick // EventStream[dom.MouseEvent]
```

Now you need to use a slightly different syntax **\[Migration\]**:

```scala
windowEvents(_.onPopState) // EventStream[dom.PopStateEvent]
documentEvents(_.onClick) // EventStream[dom.MouseEvent]
```

You can also specify any event processor now, e.g.:

```scala
documentEvents(_.onClick.useCapture.preventDefault)
```



### `:=> Unit` Sinks

Currently you can put any `A => ()` or `Sink[A]` on the right hand side of `-->` methods, including `Observer[A]`, `EventBus[A]`, and `Var[A]` (pro tip – you don't even need `.writer` for those, that's oldskool).

We have a lot of helpers and convenience methods optimized to make use of this to reduce boilerplate, for example:

```scala
input(
  onInput.mapToValue --> myVar.updater(_ :+ _),
  onInput.mapToValue.map(_.toInt) --> intObserver,
  onInput.mapToValue --> intObserver.contramap[Int](_.toInt),
  onClick --> { _ => println("hello") },
  onClick.mapTo("hello") --> println
)
```

Read the Laminar docs – on event handling, vars, observers, etc. – to get a fuller picture.

Unfortunately some of these helpers suffer from being unintuitive, and require a good understanding of Laminar types to use effectively. For example:
* `myVar.updater` is basically a variation of its `update` method that returns an Observer,
* `onClick --> { _ => println("hello") }` is annoyingly verbose, and
* `onClick.mapTo("hello") --> println` splits the responsibility in a rather weird way.

To simplify some of these usage patterns, Laminar is now allowing side effects that are typed simply as `:=> Unit`, for example:

```scala
import com.raquo.laminar.api.features.unitArrows // enable this feature
input(
  onClick --> println("hello"),
  onClick --> myVar.update(_.append(""))
)
```

There is no magic to it, these `--> methods` simply accept a `Unit` expression, which is then re-evaluated on every event (that's what `:=>` does in the function signature). Great suggestion by [@Lasering](https://github.com/Lasering).

Unfortunately, while this kind of API is perfectly safe in Scala 2, that is not the case in Scala 3. Specifically, in Scala 3, the expression `if (true) observer` is typed as `Unit` and returns `()`, instead of being typed as `Any` and returning `observer`.

So, in Scala 3, code like `div(onClick --> if (bool) observer)` will compile without warnings, but will not actually call the observer. We can't have that, because beginners might legitimately try to write such code when what they really want is e.g. `div(onClick.filter(_ => bool) --> observer)`.

To prevent such accidents, this new unit-based API requires a special import. If you forget the import, the compiler will give you an error pointing to documentation about this caveat. It's up to you to choose between extra brevity and extra safety. With IntelliJ importing the required implicit is only one command away, so it's not much of an annoyance.



### Improvements to children operations

After numerous fixes and additional safeguards, it is now safe to do various "weird" things with dynamic child elements:

* You can now safely move an element in between any `children <--` / `child <--` inserters (it will be safely removed from its last location, as a DOM element can only exist in one location at a time)
* You can now return different types of `children <--` / `child <--` inserters from `onMountInsert` on every mount, and have them interoperate safely when re-mounting.
* Laminar can now gracefully recover from any external code removing an element from inside `children <--` or `child <--`.
* **Migration:** Generally all this should work as-is, however under the hood Laminar outputs slightly different DOM elements. Specifically, it may create empty comment nodes (sentinels) before `child <--` elements, and `child.text <--` that are called from `onMountInsert`, to better keep track of the nodes being moved. This does not affect rendering, but your tests might fail if they don't expect those comment nodes.

The list of children is no longer cleared when unmounting a component with `children <-- stream`.

* **Migration:** this change matches the new Airstream semantics. See the general instructions about that in the section below.

Improvements to rendering text nodes:

* `child.text` can now render not only strings, but any `A` for which there is an implicit instance of `Renderable[A]`. By default, this includes strings, chars, numbers, and booleans. If you had implicit conversions to `TextNode`, you should do this instead.

* `child.text` now updates the content of text nodes instead of re-creating them on every event.



## New Airstream Semantics

We changed how Airstream observables propagate events to solve long standing ergonomics issues. The **migration** will require a manual review of some parts of your code – see suggestions below.



### No More Automatic `==` Checks in Signals

Prior to this release, an Airstream Signal would skip emitting a value that is `==` equal to its current state. For example, if you had `val signal = stream.startWith(0)` and `stream` emitted event `1` twice in a row, `signal` would only emit `1` once, it would not emit it the second time, because the value of the state that it represents didn't actually change. This behaviour was supposed to deduplicate / declutter signal updates, and overall better serve the "state" semantic of Signals, but ultimately it caused more issues than it solved.

On a practical level, some `==` checks could be expensive when they evaluate structural equality (e.g. checking the equality of large collections like lists or maps). And this work is performed on every event and at every signal operator, every time you `map` / `filter` / etc. that data. And then when you hand over the result to `children <--`, the diffing algorithm essentially does the same job again, resulting in lots of redundant computations.

Worst of all, there wasn't really a good way to disable this behaviour. You would need to either use streams, or wrap your data in useless types like `class Ref[A](val v: A)` whose only job is to force comparison by reference equality.

In Airstream 15.0.0 signals no longer perform `==` checks, they emit every event just like streams. This makes all observables' behaviour more uniform, eliminating `==` checks as a decision factor when choosing the data type.

??? ... To account for this, Laminar now performs automatic deduplication where observables meet the DOM. For example, if you have `a(href <-- signal)`, and `signal` emits `hello` twice, the input's `href` property will only be updated to `hello` once.

**Warning: currently in 15.0.0-M1 this might cause problems if you have two streams feeding the same attribute on the same element. But those problems wouldn't be any worse than what two SIGNALS would do in Laminar 0.14.x. I'm not sure if anyone uses Laminar with two streams like this, but so far this has been a valid use case. If you do use this feature, please let me know. I need to benchmark the performance of various solutions.**

TODO – I think we should disable auto-distinction in the DOM? Check performance.



#### New `distinct*` operators

Both streams and signals now have various `distinct*` operators to enable `==` or other conditional checks as needed. These can be used to make your signals behave like they did prior to the update, or achieve different, custom logic:

```scala
signal.distinct // performs `==` checks, similar to pre-15.0.0 behaviour
signal.distinctBy(_.id) // performs `==` checks on a certain key
signal.distinctByRef // performs reference equality checks
signal.distinctByFn((prevValue, nextValue) => isSame) // custom checks
signal.distinctErrors((prevErr, nextErr) => isSame) // for the error channel
signal.distinctTry((prevTryValue, nextTryValue) => isSame) // one comparator for both event and error channels
```

The same operators are available on streams too.

#### `split` operator distinction

The `split` operator internally uses `==` checks to determine whether each record in the collection has changed or not. If not for these `==` checks, `split` would trigger a useless update for every child on every incoming event, instead of triggering only on the child that was actually affected by the event.

To maintain this behaviour, the `split` operator now has a second parameter called `distinctCompose` which indicates how exactly the values are to be distinct-ed, and defaults to `_.distinct`, to match the previous behaviour of `==` checks. You can override it to provide a custom distinctor function if desired:

```scala
children <-- nodesStream.split(_.id, _.distinctBy(customComparator))(...)
```


#### Migration: 

The most straightforward solution is to call `distinct` on any Signal that you want to behave like it used to. The challenge is to find which signals need such treatment – a manual review is required, there is no way around it. I suggest focusing on the following cases:

* Any place where you _know_ that you relied on signals performing `==` checks.
* Signals that drive side effects, such as making network requests or updating `Var`-s in non-idempotent ways.
* Signals that emit their updates into EventBus-es or Var-s 
* Observables or Vars that _accumulate_ values from some input, e.g. `observable.foldLeft(...)((acc, next) => newAcc)` – if `observable` is a signal, or a stream that depends on a signal, it might be emitting more events now than before.
* `flatMap` and `flatten` calls that might involve per-event side effects.
* Signals or Vars that depend on each other in a loop – if you were previously relying on the implicit `==` filter to terminate the loop, the lack of such filter might result in an infinite loop now. 
* Any state logic that is complex for any reason.

During this migration, adding an extraneous `.distinct` is rather unlikely to cause breakage, so if you're not quite sure about some suspicious signal, you can start by `.distinct`-ing it. You can try undoing it later as time allows. Remember, you don't need to `.distinct` literally every signal to match previous behaviour, it pretty much only matters at the edges, where you trigger non-idempotent side effects.



### Signals Now Try to Re-sync After Restarting

This is a solution to [#43](https://github.com/raquo/Airstream/issues/43). Suppose we have:

```scala
val parentSignal: Signal[Foo] = ???
val childSignal: Signal[Bar] = parentSignal.map(fooToBar)

span(
  backgroundColor <-- childSignal.map(bar => bar.color)
)
```

Since `childSignal`'s value is very explicitly derived from `parentSignal`'s value, you generally expect their values to be in sync at all times. And this is true as long as both signals are **started**, that is, have observers. However, `childSignal` can become **stopped** if it loses all of its observers, e.g. if this `span(...)` was to be **unmounted** from the DOM.

If this happens, `childSignal` will stop listening to `parentSignal` (observables are lazy), and if `parentSignal` does not get stopped at the same time (it might have other observers), `parentSignal`'s value might be updated while `childSignal` is not listening.

This becomes a problem when `childSignal` is restarted again, e.g. because you decided to mount that same exact `span(...)` again instead. Until Airstream 15.0.0, doing that would have caused `childSignal` to be out of sync with `parentSignal` because it missed the parent's update while it was stopped – it would only sync up again if / when `parentSignal` emitted the next update. In Airstream 15.0.0, `childSignal` now "pulls" the parent's latest value when restarting, and updates its own value to match (calling `fooToBar` in this case). Note that this "pull" only happens if `parentSignal` has actually emitted any value while `childSignal` was stopped (otherwise it's just not needed).

This new technique keep signals synced with each other pretty well, but it's not perfect. Some examples:
* The `childSignal` will only get the _latest_ value of `parentSignal` when restarting, even if `parentSignal` emitted several times while `childSignal` was stopped. This might be important for signals like `parentSignal.scanLeft(...)(...)`. 
* If you have `signal = parentStream.startWith(1)`, your `signal` can't "pull" any updates it missed from `parentStream`, because unlike signals, streams don't have a "current value" and don't "remember" their last emitted event – if you miss a stream event, you're not getting it back.

**Migration:** Review components that reuse elements after they were unmounted. For example, in the snippet below, `warningElement` is being reused like this, and in the new Laminar, its `child.text` will be updated to sync up with `parentSignal` whenever `boolSignal` emits `true`, even if `parentSignal` never emits while `warningElement` is actually mounted:

```scala
val boolSignal: Signal[Boolean] = ???
val parentSignal: Signal[String] = ???
val warningElement = div(
  h1("The yeti is onto us!"),
  child.text <-- parentSignal.map(_.toUpperCase)
)
div(
  child <-- boolSignal.map(if (_) warningElement else emptyNode)
)
```

Remember that this change does not affect elements that are not reused after being unmounted. Note that `child` / `children` fed by `split` / `splitOne` do not reuse elements in this manner by themselves when switching between children, this changes affects the specific pattern where you save a Laminar element in a `val` and then use the same `val` repeatedly in `child <-- ...` or `children <-- ...`.



#### signal.changes re-sync after restarting

Unlike other streams, the **`signal.changes`** stream does re-sync when restarting – and just like other signals, they do it only if `signal` has emitted a value while `signal.changes` was stopped.

However, streams are unable to propagate updates without emitting an event to all of their children. So, when re-syncing upon restarting, `signal.changes` emits the signal's latest value in a new transaction, and more importantly, **this transaction is shared** between all the `.changes` streams of your various signals that are being restarted at the same time. For example, if you re-mount a previously unmounted element which uses a bunch of `.changes` streams on unrelated signals provided by the parent component, all of those .changes streams will emit in the same transaction, even if it is normally impossible for them to emit in the same transaction. For example:

```scala
div(
  parentSignal.changes.map(foo) --> fooObserver,
  parentSignal.changes.flatMap(_ => EventStream.fromValue(bar)) --> barObserver
)
```

`changes.map(...)` and `changes.flatMap(...)` normally can never emit in the same transaction, but in this case, when re-syncing, they will. This is undesirable, but for the re-syncing use case, that is the cost of re-syncing the `.changes` stream. I think overall this strategy provides the best ergonomics, as users are much more likely to be annoyed at `signal.changes` not re-syncing at all, than they are to run into a situation where this imperfection is causing a problem due to using a shared transaction.

**Migration:** Review components that reuse elements after they were unmounted – see the `warningElement` example above. In the snippet above, you can avoid the new re-syncing logic by replacing `val warningElement` with `def warningElement` – this will cause Laminar to re-create the element instead of re-mounting an existing one – this will not match previous behaviour, but will solve any issues you might be having due to the shared transaction mechanism in the `.changes` re-sync.



### Observables No Longer Reset Their Internal State When Stopped

Until this new Airstream version, our design generally assumed that when an observable is stopped, the user would want to clear / reset its state. Combined with source observables like `EventStream.fromValue(v)` and `AjaxEventStream` defaulting to `emitOnce = false`, that is, re-emitting their events on **every** start, this was a reasonable way to approach the problem of properly reviving Laminar components after they have been unmounted and mounted again.

As a concrete example, in past Airstream versions, after `stream1.combineWith(stream2)` was restarted, it would not start emitting events again until **both** stream1 and stream2 emitted a new event, because when the combined stream was stopped, it "forgot" the previous events that its parent streams emitted.

So in that example, if your `stream1` and `stream2` streams also re-emitted during this restart, everything would be fine, the combined stream would emit the new combined event, and you would get the expected result. However, not all streams behaved that way, and so this restarting paradigm was not always helpful.

The new restarting paradigm is pretty much the opposite – if stopped and restarted, the observables generally remember their last known state, and the signals even try to re-sync their state when they're started again (see the section above).


Airstream's general paradigm now is to "pause" the observables when they are stopped, and seamlessly "resume" them when they are restarted, instead of tearing down on stop, and restarting them from scratch on restart.

**Migration:** Review components that reuse elements after they were unmounted – see the `warningElement` example above. Remember that this change does not affect elements that are not reused after being unmounted.



## New Airstream Features



### New `splitByIndex` operator

Sometimes you want to use the `split` operator to efficiently render a dynamic collection of items, but these items don't have a suitable `id`-like key required by `split`. There are a couple ways to work around this, but the easiest is using the index of an item in the collection as its unique key. Now there is a special operator that does it for you:

```scala
val modelsStream: EventStream[List[Model]] = ???
children <-- modelsStream.splitByIndex((ix, initialModel, modelSignal) => div(...))
```


### New `splitOption` operator

Another convenience method lets you split an observable of Option-s using .isDefined as key:

```scala
val modelOptionStream: EventStream[Option[Model]] = ???
child <-- modelOptionStream.splitOption(
  (initialModel, modelSignal) => div(...),
  ifEmpty = div("No model currently")
)
```

You can provide `ifEmpty = emptyNode` if you don't need it. That said, the regular `split` works with options too, in fact that's how `splitOption` is implemented. 



### Duplicate key warnings for the `split` operator

Airstream's `split` operator does not tolerate items with non-unique keys – this is simply invalid input for it, and it will crash and burn if provided such bad data.

The new Airstream version enables duplicate key warnings by default. **Your code will still break** if the `split` operator encounters duplicate keys, but it will first print a warning in the browser console listing the duplicate keys at fault.

Thus, these new warnings do not affect the execution of your code, and can be safely turned on for debugging or turned off for performance. You can adjust this setting both for your entire application, and for individual usages of `split`:

```scala
// Disable duplicate key warnings by default
DuplicateKeysConfig.setDefault(DuplicateKeysConfig.noWarnings)

// Disable warnings for just one split observable
stream.split(_.id, duplicateKeys = DuplicateKeysConfig.noWarnings)(...)
```



### New `take` and `drop` operators

The new `stream.take(numEvents)` operator returns a stream that re-emits the first `numEvents` events emitted by the parent `stream`, and then stops emitting. `stream.drop(numEvents)` does the opposite, skipping the first `numEvents` events and then starting to re-emit everything that the parent `stream` emits.

These operators are available with several signatures:

```scala
stream.take(numEvents = 5)
stream.takeWhile(ev => passes(ev)) // stop taking when `passes(ev)` returns `false`
stream.takeUntil(ev => passes(ev)) // stop taking when `passes(ev)` returns `true`
```

```scala
stream.drop(numEvents = 5)
stream.dropWhile(ev => passes(ev)) // stop skipping when `passes(ev)` returns `false`
stream.dropUntil(ev => passes(ev)) // stop skipping when `passes(ev)` returns `true`
```

Like some other operators, these have an optional `resetOnStop` argument. Defaults to `false`, but if set to `true`, they "forget" all past events, and are reset to their original state if the parent stream is stopped and then started again.



### New `filterWith` operator

`stream.filterWith(signalOfBooleans)` emits only when the given signal's (or Var's) current value is `true`.

Can be used with Laminar's new `compose` method to filter DOM events too: 

```scala
div(onClick.compose(_.filterWith(clickEnabledVar)) --> observer)
```



### FetchStream

Airstream core now has a convenient interface to make network requests using the modern [Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) browser API:

```scala
FetchStream.get(
  url,
  _.redirect(_.follow),
  _.referrerPolicy(_.`no-referrer`),
  _.abortStream(...),
) // EventStream[String] of response body
```

You can also get a stream of raw `dom.Response`-s, or use a custom codec for requests and responses, all with the same API:

```scala
FetchStream.raw.get(url) // EventStream[dom.Response]
```

```scala
FetchStream
  .withCodec(encodeRequest, decodeResponse)
  .post(url, _.body(myRequest)) // EventStream[MyResponse]
```



### New `collectSome`, `collectOpt` operators

```scala
val stream: EventStream[Option[A]] = ???
stream.collectSome // EventStream[A]
```

```scala
val stream: EventStream[List]
streamOfList.collectOpt(NonEmptyList.from) // EventStream[NonEmptyList]
// Note: NonEmptyList.from(list) returns Option[NonEmptyList]
```



### New `EventStream.delay(ms)` shorthand

`EventStream.delay(ms, optionalValue)` emits `optionalValue` (or `()` if omitted) `ms` milliseconds after the stream is started. Useful to delay some action after the component is mounted, e.g.:

```scala
div(
  EventStream.delay(5000) --> showBelovedMarketingPopup
)
```



### New: Signal.fromFuture with initial value

`Signal.fromFuture(future)` produces a `Signal[Option[A]]` which you can work around, but is annoying. Now you can specify `initialValue: A` as the second argument, and get a `Signal[A]` that will start with that value if the `future` is not yet resolved. 



### New: Flatten streams of signals

We now have a FlattenStrategy that supports this particular combination of observables before. This: `stream.flatMap(v => makeFooSignal(v))` now returns `EventStream[Foo]`, and works similar to switching streams, with the signal's current value considered an "event" when switching to a new signal.

As a result, you can now also flatten `Observable[Signal[A]]` into `Observable[A]`.



### New `throwFailure` operator

Turns `Observable[Try[A]]` into `Observable[A]`, moving the failure into the error channel. From when you want to un-recover from `recoverToTry`.



## Changes to Airstream `scala.Future` integration 

Airstream lets you create streams and signals from scala Futures and JS promises. Future-based functionality is now implemented using `js.Promise`, instead of the opposite, to avoid surprising behaviour in some edge cases.

This means that if you don't explicitly use Futures, your code is now scala.Future-free, and your JS bundle should get slimmer as a result (unless your other dependencies still use Futures).

**Migration:** This results in the following breaking changes:

* API: `Signal.fromFuture` always emits asynchronously now, that is, it always starts with a None value (or the provided initial value), even if the future/promise has already resolved when it's observed (because there's absolutely no way to synchronously observe the content of a `js.Promise`).

* `EventStream.fromFuture` does not offer the emitIfFutureCompleted option anymore, it is now always on. It also has a new option: emitOnce.

* API: Internet Explorer 11 support now requires a `js.Promise` polyfill to use `fromFuture` methods, because Internet Explorer does not natively support JS Promises. See [stackoverflow](https://stackoverflow.com/questions/36016327/how-to-support-promises-in-internet-explorer-11).

* API: Removed `SwitchFutureStrategy`, you can't directly flatten observables of futures anymore, because that behaviour isn't defined well enough.

  * **Migration:** When flattening observables of futures, wrap them in `EventStream.fromFuture` or `Signal.fromFuture` to make sure that you're getting what you expect. Then SwitchStreamStrategy or SwitchSignalStrategy will apply.

* API: Disabled implicit conversions from Future and js.Promise to `Source`. They're not smooth / obvious enough to be implicit.

  * **Migration**: same, doing it explicitly.

* API: `fromFuture` methods require an implicit `ExecutionContext` now.

  * **Migration:** Read [this explanation](https://www.scala-js.org/news/2021/12/10/announcing-scalajs-1.8.0/) by the Scala.js team, and choose which execution context you want to use.

* Timing: Future-based streams have a few milliseconds of extra latency now as the futures need to be translated to js.Promise. Since they're asynchronous by nature, this shouldn't be a problem, but if you're very unlucky, this might expose previously unknown expose conditions in your code.



## Minor Breaking Changes

**Migration** should be obvious for these. Most of these likely won't even affect you.

**Laminar**

* We no longer use names that start with the `$` symbol, because even though such code compiles, such names are reserved for the Scala compiler use. Laminar itself used such names very sparsely, but if you did reference those names, replacements should be obvious as they are mostly method param names. See [#127](https://github.com/raquo/Laminar/issues/127). Thanks to [@TheElectronWill](https://github.com/TheElectronWill) for noticing!

* Laminar node types like `ChildNode` don’t extend the corresponding `com.raquo.domtypes` types anymore (they were removed from domtypes)

* Some rarely used CSS style shorthands like `unicodeBidi.embed` were removed. Use regular strings to set the desired values, e.g. `unicodeBidi := “embed”`

* `CompositeKey` now extends `Key`, and the various `:=` methods now return `CompositeKeySetter`, a more specific subtype of Setter. **Migration:** watch out if you use pattern matching on `Key` subtypes.

* `DomApi.createHtmlElement` accepts `HtmlTag` now instead of `HtmlElement`. Similarly for `createSvgElement`.

* Removed deprecated methods

**Airstream**

* `Var.update` no longer throws exceptions on invalid input, all errors are now reported via Airstream's unhandled-errors mechanism for consistency (previously the behaviour depended on the type of error).

* `split` operator now provides signals only, no streams. This goes both for the return value of the operator and the argument type of the callback that it accepts.

* Remove `splitIntoSignals` method – use `split` (see above)

* `Debugger` doesn't have `topoRank` field anymore (it was useless)

* Remove `Id[A] = A` type from `util` – define your own if you need it

* Remove hidden `Ref` util class – use the new `distinct*` methods

* EventStream.periodic

  * `resetOnStop` default changed from `true` to `false` in accordance with new semantics

  * Removed `emitInitial `option. It's always `true` now. Use the new `drop(1, resetOnStop = true)` operator to approximate previous `emitInitial = false` behaviour.

* `Signal.fromCustomSource` now requires `Try[A]` instead of `A` for initial value.

* Removed deprecated methods



## Changes Only Relevant To Laminar & Airstream Extensions

**Migration:** These changes are only relevant to library authors and advanced users who extend Airstream and Laminar classes – the vast majority of regular end users are not affected by these changes. This is not a 100% exhaustive list of such internal changes, but it should cover all significant changes, as well as changes that are hard to grasp from just the compiler errors.

* All `<X>EventStream` types were renamed to `<X>Stream`, except for `EventStream` itself and `DomEventStream`. The renamed types are not really user-facing except for `AjaxEventStream`, for which a deprecated alias is provided for now.
  * You know what it feels like to have `<X>Stream.scala` and `<X>Signal.scala` files always next to each other when sorted alphabetically? Bliss.

* `Modifier` type moved from _Scala DOM Types_ to Laminar

* `Modifier`'s generic type param is constrained now, so you can’t use `Modifier[_]` won't compile anymore, use `Modifier[_ <: ReactiveElement.Base]` instead.

* No more `SingleParentObservable`. Replace with `SingleParentSignal` and `SingleParentStream`

* `Splittable` now requires `empty`. `IdSplittable` is removed.

* Rename `Protected.maxParentTopoRank` to `Protected.maxTopoRank`

* Laminar `Key` types like `ReactiveProp`, `ReactiveHtmlAttr`, etc. don’t extend the corresponding `com.raquo.domtypes` types anymore (those types were removed from _Scala DOM Types_), and also they were renamed (see "User-facing renamings" section below)

* Laminar `Node` types like `ChildNode` don’t extend the corresponding `com.raquo.domtypes` types anymore (those types were removed from _Scala DOM Types_)

* `ReactiveHtmlElement` and `ReactiveSvgElement` now accept `ref` as a parameter. Use this wisely. Note that new helper methods are now available to inject foreign elements into Laminar tree (see above), so you shouldn’t need to use these constructors directly.

* `BaseObservable#equals` method now always compares observables by reference, and that's made `final`. In practice this means that creating case class subtypes of observables won’t accidentally break Airstream.

* `Subscription.isKilled` method is now public, you can use it to check if it's safe to kill a subscription.

* Some Laminar implicit conversions like `nodesArrayToInserter` and `nodesArrayToModifier` were renamed, and new ones were added.

* Individual N-arity classes like `CombineSignal2` were replaced with `CombineSignalN` factory functions to reduce bundle size.
  
* Semi-internal class renamings: `MaybeChildReceiver` -> `ChildOptionReceiver`, `TextChildReceiver` -> `ChildTextReceiver`,  



## New Minor Conveniences

**Laminar**

* `mapToFiles` to get list of files for upload: `input(typ("file"), onChange.mapToFiles --> filesObserver))`
* `HtmlMod`, `SvgMod` type aliases
* `Modifier.apply`
* `Setter.empty`
* `Modifier.Base`, `Modifier.Any`, `Setter.Base`, `Binder.Base` type aliases
* `DomApi.debugNodeOuterHtml`, `DomApi.debugNodeInnerHtml` (null-safe)

**Airstream**

* `EventBus.apply`
* `EventStream.withUnitCallback` to get a stream that's updatable via a parameter-less callback
* `mapToUnit` operator, just `mapTo(())`
* `stream1.mergeWith(stream2, stream3)` – alias for `EventStream.merge(stream1, stream2, stream3)`



## Other Minor Changes

**Laminar**

* API: `matchStreamOrSignal` is now available on `Observable`

* Fix: Prevent text cursor from jumping to the end of the input in Safari when using the controlled-input pattern without using Laminar’s `controlled` method. ([#110](https://github.com/raquo/Laminar/issues/110))

* API: `StyleSetter` no longer has a type param.

* API: `cls` is now a composite attribute, not a composite property. There should be no observable difference other than change in type.

* API: You can now pass the two arguments to `controlled()`in reverse order too

* Build: You need a more modern version of node.js to run Laminar tests now. I forget the exact version, but I think v14 is the minimum now. I recommend installing a much newer one, perhaps v18 LTS.


**Airstream**

* API: DerivedVar zoomOut parameter now provides the parent Var's current value as the first param. **Migration:** update existing usages of `parentVar.zoom(in)(out)` method to `parentVar.zoom(in)((parentValue, derivedValue) => out(derivedValue))`, or better yet, make use of `parentValue` instead of calling `parentVar.now()` in your `out` function.

* Fix: Debug logging does not wrap text in extraneous "Some()" and "None" anymore

* API: Removed `cacheInitialValue` option from `CustomSignalSource` – it did not work, so this should not change any behaviour


## User-facing Renamings

**Migration:** find and rename these as they fail to compile. Other renamings will show deprecation warnings.

**Laminar**

* Many Laminar DOM tag names now have a `Tag` suffix, e.g. `time` -> `timeTag`, `main` -> `mainTag`, `header` -> `headerTag`, `section` -> `sectionTag`.

* Laminar `Key` types were renamed: like `ReactiveProp -> HtmlProp`, `ReactiveStyle` -> `StyleProp`, `ReactiveEventProp` -> `EventProp`, `ReactiveHtmlAttr` -> `HtmlAttr`, `ReactiveSvgAttr` -> `SvgAttr`,  `ReactiveComplexHtmlKeys` -> `ComplexHtmlKeys`, `ReactiveComplexSvgKeys` -> `ComplexSvgKeys`, `CompositeProp[_]` -> `CompositeHtmlProp`.

  * **Note that `ReactiveHtmlElement` and `ReactiveSvgElement` types keep their current names!**

* `EventListener.Any` -> `EventListener.Base`

* `customHtmlAttr`, `customSvgAttr`, `customProp`, `customStyle` renamed – see deprecation notices

* `content` style prop renamed to `contentCss` to avoid being shadowed by a common variable name.

* `KeyUpdater.$value` -> `KeyUpdater.values`

**Airstream**

* EventStream.withUnitCallback

* Observable operators:
  * `contramapOpt` -> `contracollectOpt`
  * `foldLeft` and `foldLeftRecover` -> `scanLeft` and `scanLeftRecover`

* Manual dynamic subscription factories require that you don't manually kill the `Subscription` that you create, that you let the resulting DynamicSubscription manage it. They were renamed and commented to reflect that:
  * `DynamicSubscription.apply` -> `DynamicSubscription.unsafe`
  * `ReactiveElement.bindSubscription` -> `ReactiveElement.bindSubscriptionUnsafe`

* `DomEventStreamPropBuilder` -> `StreamEventPropBuilder`

* Debug API
  * `debugSpyInitialEval` -> `debugSpyEvalFromParent`
  * `debugBreakInitialEval` -> `debugBreakEvalFromParent`
  * `debugLogInitialEval` -> `debugLogEvalFromParent`
  * `Debugger.onInitialEval` -> `Debugger.onCurrentValueFromParent`


